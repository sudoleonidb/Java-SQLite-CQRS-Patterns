CQRS (Command Query Responsibility Segregation) - это архитектурный паттерн,
который разделяет операции записи (команды) и чтения (запросы) на два разных интерфейса.
Это позволяет оптимизировать каждую из этих операций отдельно, давая больше гибкости в дизайне
и производительности.

Основные концепции CQRS:

Разделение: Операции чтения и записи разделены.
Это значит, что у тебя будет один интерфейс (или набор классов/сервисов) для обработки команд и
 другой интерфейс для обработки запросов.

Асинхронность: CQRS часто используется в сочетании с паттерном Event Sourcing.
После выполнения команды (операции записи) могут генерироваться события,
которые затем обрабатываются асинхронно для обновления проекций или представлений,
используемых для чтения.

Масштабируемость: Поскольку чтение и запись разделены,
каждую из этих операций можно масштабировать независимо.
Например, если у тебя много операций чтения, можно увеличить количество реплик базы данных,
оптимизированных для чтения, не затрагивая операции записи.

Гибкость в моделировании данных: Так как операции чтения и записи не зависят друг от друга,
ты можешь оптимизировать структуру данных для каждой из них отдельно. Например,
 структура данных для записи может быть нормализована, тогда как для чтения -
 денормализована для ускорения запросов.

Примечание: Несмотря на все преимущества,
CQRS вносит дополнительную сложность в архитектуру приложения.
Его стоит использовать только в случаях, когда требования к производительности
и масштабируемости оправдывают эту сложность.

В общем, CQRS предлагает мощный инструмент для разделения и оптимизации операций чтения и записи,
особенно в сложных и масштабируемых системах.

_____________________
_____________________
Данный пример иллюстрирует разделение команд и запросов:
мы используем AddUserCommand для добавления пользователя
и GetAllUsersQuery для извлечения списка пользователей из
базы данных.

Обратите внимание, что на практике CQRS часто используется в
комбинации с другими паттернами и архитектурными подходами,
такими как Event Sourcing, и может быть гораздо сложнее этого
базового примера.
_____________________
_____________________
Описание примера:
Определение интерфейсов:

Command: Этот интерфейс представляет команду — действие,
 которое изменяет состояние системы.
Query<R>: Этот интерфейс представляет запрос.
В отличие от команды, запрос не изменяет состояние системы,
но возвращает некоторые данные. R - это тип возвращаемых данных.


Реализация команды (запись):

AddUserCommand: Этот класс реализует добавление пользователя в базу данных.
Его задача — только запись, не возвращая результат.

Реализация запроса (чтение):

GetAllUsersQuery: Этот класс отвечает за извлечение
списка пользователей из базы данных. Его задача — только чтение.

Основной класс:

CQRSExample: Этот класс демонстрирует применение CQRS в действии.
Сначала он создаёт соединение с SQLite, затем использует команду
для добавления пользователя и запрос для извлечения списка пользователей.
Документация:
CQRS (Command Query Responsibility Segregation) — это архитектурный паттерн,
который разделяет ответственность за команды (изменяющие состояние) и запросы (возвращающие данные).

Команды (Commands): Операции, которые изменяют состояние системы
(например, добавление, обновление или удаление записей).
В нашем примере AddUserCommand является командой,
 которая добавляет пользователя в базу данных.

Запросы (Queries): Операции, которые извлекают информацию из системы,
 не изменяя её состояния. В нашем примере GetAllUsersQuery является запросом,
 который извлекает список пользователей.

Преимущества использования CQRS:

Гибкость: Можно независимо оптимизировать и
масштабировать операции чтения и записи.
Чистота кода: Разделяя команды и запросы,
упрощается логика каждой операции, делая код более читаемым и поддерживаемым.
Однако использование CQRS может добавить сложность к вашему приложению,
поэтому рекомендуется применять этот паттерн там, где его преимущества превышают потенциальные недостатки.


_____________________
_____________________

При запуске программы CQRSExample произойдет следующее:

Программа установит соединение с базой данных SQLite.
Если база данных с именем sample.db не существует,
она будет автоматически создана в корневой директории
вашего проекта.

Внутри базы данных проверится наличие таблицы users.
Если она не существует, будет создана новая таблица с
этим именем и столбцами id и name.

В таблицу users будет добавлен новый пользователь с именем
"John Doe" при помощи команды AddUserCommand.

Программа выполнит запрос GetAllUsersQuery,
чтобы получить список всех пользователей из таблицы users.

Полученный список пользователей будет выведен в консоль.

Для наглядного просмотра результатов выполните следующие шаги:

Запустите программу.
Откройте терминал или консоль вашей IDE.
Вы увидите вывод, например:

John Doe

(Если вы запустите программу несколько раз, то "John Doe" будет добавлен несколько раз и вы увидите его имя многократно).

Чтобы убедиться в добавлении данных в базу, вы можете использовать внешние инструменты для работы с SQLite (например, DB Browser for SQLite) и открыть файл базы данных sample.db для просмотра содержимого таблицы users.
Таким образом, вы сможете наглядно увидеть работу вашей программы и взаимодействие с базой данных.